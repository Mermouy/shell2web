require 'sinatra'
# std
require 'fileutils'
require 'open3'

def var(env_name, default=nil) ENV.include?(env_name) ? ENV[env_name] : default end 
def str_to_bool(str) str == true || str =~ /^(true|1|yes|y|on|si|aye)$/i end

# config (ugly, cleanup todo)
SHELL2WEB_CMD=var('SHELL2WEB_CMD', './run') # what to run
SHELL2WEB_CONTENT_TYPE=var('SHELL2WEB_CONTENT_TYPE', 'text/html')
SHELL2WEB_LIVE=str_to_bool(var('SHELL2WEB_LIVE', 'true')) # allow /live
SHELL2WEB_TIME=str_to_bool(var('SHELL2WEB_TIME', 'true')) # show start, end and elapsed time
SHELL2WEB_DELAY=Integer(var('SHELL2WEB_DELAY', 5*60))  # 5 minutes
SHELL2WEB_AVG_RUN_TIME=Integer(var('SHELL2WEB_AVG_RUN_TIME', 4*60))
# config

OUTPUT='tmp/output.txt'
OUTPUT_TMP='tmp/output_tmp.txt'

DAYS_PER_YEAR = 365.2425
DAYS_PER_MONTH = DAYS_PER_YEAR / 12
SECONDS_PER_DAY = 86400.0

PROJECT_URL='https://github.com/steakknife/shell2web'
BANNER = "generated by shell2web #{PROJECT_URL}"
SHELL_BANNER = "# #{BANNER}\n"
XML_BANNER = "<!-- #{BANNER} -->\n"

FORMATS=%w[html json toml txt xml yaml]
FORMAT_CONTENT_TYPES=%w[text/html application/json text/plain text/plain application/xml text/plain]

def internet_text(line)
  (line =~ /\n$/) ? (line.chop + "\r\n") : line
end

def output(dst, line)
  dst << internet_text(line)
end


FileUtils.mkdir_p('tmp')

CLEANUP = proc { FileUtils.rm_f OUTPUT_TMP }
CLEANUP.call

%w[QUIT INT TERM EXIT].map { |signal| trap(signal, &CLEANUP) } 


def seconds_to_english(sec, sep=' ')
  def plural(x, word)
    "#{x} #{(x >= 1.0 && x < 2.0) ? word : word+'s'}"
  end
  ({
    'year'   => DAYS_PER_YEAR*SECONDS_PER_DAY,
    'month'  => DAYS_PER_MONTH*SECONDS_PER_DAY,
    'week'   => 7*SECONDS_PER_DAY,
    'day'    => SECONDS_PER_DAY,
    'hour'   => 3600.0,
    'minute' => 60.0 }.map { |unit, unit_divisor|
      if (x = (sec / unit_divisor).floor) >= 1.0
        sec -= x * unit_divisor
        plural(x, unit)
      end
  }.compact << plural(sec, 'second')).join(sep)
end

def html(src, dst)
  generated_by = "Generated by <a href='#{PROJECT_URL}'>shell2web</a>&nbsp;&nbsp;&nbsp;&nbsp;"
  output dst, <<-EOS
<div id='shell2web-header'>
<br/>
<p>#{generated_by}
Get Source: <code>git clone <a href='#{PROJECT_URL}.git'>#{PROJECT_URL}.git</a></code></p>
<br/>
</div>
EOS

  output dst, "<table class='shell2web'>\n"
  output dst, "<thead class='shell2web-header'><tr><td class='hell2web-header-package'>Package</td><td id='shell2web-header-version>Version</td></tr></thead>\n"
  while line = src.gets
    output dst, "<!-- #{line.strip} -->\n" if line =~ /^#/
    output dst, "<tr class='shell2web-row'><td class='shell2web-row-package'>#{$1}</td><td class='shell2web-row-version'>#{$2}</td></tr>\n" if line =~ /^([^#]\S*)\s+(\S*)/
  end
  output dst, "</table>\n"

  output dst, <<-EOS
<div id='shell2web-footer'>
<br/>
<p>#{generated_by}</p>
<br/>
</div>
EOS
end

def json(src, dst)
  output dst, "{\n"
  skip = true
  while line = src.gets
    output dst, "#{skip && ','}\"#{$1}\": \"#{$2}\"\n" if line =~ /^([^#]\S*)\s+(\S*)/
    skip &&= false
  end
  output dst, "}\n"
end

def toml(src, dst)
  output dst, SHELL_BANNER
  while line = src.gets
    output dst, line if line =~ /^#/
    output dst, "#{$1} = \"#{$2}\"\n" if line =~ /^([^#]\S*)\s+(\S*)/
  end
end

def xml(src, dst)
  output dst, '<?xml version="1.0" encoding="UTF-8"?>'"\n"
  output dst, XML_BANNER
  output dst, "<packages>\n"
  while line = src.gets
    output dst, "<!-- #{line.strip} -->\n" if line =~ /^#/
    output dst, "<package><name>#{$1}</name><version>#{$2}</version></package>\n" if line =~ /^([^#]\S*)\s+(\S*)/
  end
  output dst, "</packages>\n"
end

def yaml(src, dst)
  output dst, "---\n"
  output dst, SHELL_BANNER
  while line = src.gets
    output dst, line if line =~ /^#/
    output dst, "#{$1}: #{$2}\n" if line =~ /^([^#]\S*)\s+(\S*)/
  end
end

def txt(src, dst)
  while line = src.gets
    output dst, line
  end
end

def cached_render(format, dst)
  File.open(OUTPUT, 'r') {|src| send(format, src, dst) } 
end

def run(dst) 
  # header
  if SHELL2WEB_TIME
    start_date = Time.now
    dst << "# started: #{start_date}\n"
  end

  # body
  exit_status = nil
  Open3.popen2e(SHELL2WEB_CMD) { |stdin, stdout_and_stderr, wait_thr|
    stdout_and_stderr.each {|line|
      dst << line
      STDERR.puts "run, line: #{line}"
    }
    exit_status = wait_thr.value
  }

  # footer
  last = "exit code: #{exit_status.to_i}" 
  if SHELL2WEB_TIME
    end_date = Time.now
    elapsed_seconds = end_date - start_date
    last = "finished: #{end_date}   elapsed: #{seconds_to_english(elapsed_seconds)}  " + last
  end
  dst << "# #{last}\n"

  exit_status.success?
end

def live_render(format, dst)
  rd, wr = IO.pipe

  Thread.new do
    run(wr)
    wr.close
  end

  send(format, rd, dst) # like:  eval "#{format}(rd, dst)"
end


def fix_format(format)
  case format
  when '', nil
    'html'
  when 'text'
    'txt'
  else
    format
  end
end

########################################### CODE

# background worker to update cached copy for /
Thread.new do
  loop do
    if File.exist? OUTPUT_TMP
      STDERR.puts 'Another thread is updating.... Sleeping'
      sleep SHELL2WEB_DELAY
      next
    end
    STDERR.puts 'Updating'
    File.open(OUTPUT_TMP, 'w') { |dst| run(dst) }
    FileUtils.mv(OUTPUT_TMP, OUTPUT, :force => true)
    STDERR.puts 'Updated... Sleeping'
    sleep SHELL2WEB_DELAY
  end
end

before do
  content_type SHELL2WEB_CONTENT_TYPE
end

get %r{^/live(/(|txt|text|html|yaml|xml|toml|json))?$} do |_, format|
  format = fix_format(format)
  content_type FORMAT_CONTENT_TYPES[FORMATS.index(format)]
  stream do |response_body|
    live_render(format, response_body)
  end
end if SHELL2WEB_LIVE

get %r{^/(|txt|text|html|yaml|xml|toml|json)$} do |format|
  format = fix_format(format)

  if ! File.exist? OUTPUT
    up_to_estimate = SHELL2WEB_AVG_RUN_TIME + SHELL2WEB_DELAY
    return [503, {'Content-Type' => 'text/plain'}, "No output right now.   Takes up to #{seconds_to_english(up_to_estimate)} have results."]
  end

  content_type FORMAT_CONTENT_TYPES[FORMATS.index(format)]
  stream do |response_body|
    cached_render(format, response_body)
  end
end
